using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using SoulEngine.SequenceScript.Machine;
using SoulEngine.Util;
using ExecutionContext = System.Threading.ExecutionContext;
using ValueType = SoulEngine.SequenceScript.Machine.ValueType;

namespace SoulEngine.SequenceScript.Compile;

public static class StandardLibraryGenerator
{
    public static string GenerateStandardLibrary(Type type)
    {
        StringBuilder builder = new StringBuilder();

        builder.AppendLine("// Standard library generated by StandardLibraryGenerator");

        foreach (var function in type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy))
        {

            LibraryInterruptAttribute? attribute = function.GetCustomAttribute<LibraryInterruptAttribute>();
            if(attribute == null)
                continue;
            
            if(function.GetParameters().Length != 1)
                continue;
            
            if(function.GetParameters()[0].ParameterType != typeof(InterruptContext))
                continue;
            
            

            builder.Append("proc extern " + ConvertType(attribute.ReturnValue) + " " + attribute.ID + "(");
            for (int i = 0; i < attribute.Parameters.Length; i++)
            {
                builder.Append(ConvertType(attribute.Parameters[i]) + " attribute" + i);
                if (i < attribute.Parameters.Length - 1)
                    builder.Append(", ");
            }

            builder.AppendLine("); // Generated from " + function.Name);

        }

        return builder.ToString();
    }

    private static string ConvertType(ValueType? valueType)
    {
        return valueType switch
        {
            ValueType.Integer => "int",
            ValueType.Floating => "float",
            ValueType.Boolean => "bool",
            ValueType.String => "string",
            ValueType.Handle => "handle",
            ValueType.Void => "void",
            null => "void",
            _ => throw new ArgumentOutOfRangeException(nameof(valueType), valueType, null)
        };
    }

    public static void RegisterInterrupts(object handler, SoulEngine.SequenceScript.Machine.ExecutionContext context)
    {
        
        foreach (var function in handler.GetType().GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy))
        {

            LibraryInterruptAttribute? attribute = function.GetCustomAttribute<LibraryInterruptAttribute>();
            if(attribute == null)
                continue;
            
            if(function.GetParameters().Length != 1)
                continue;
            
            if(function.GetParameters()[0].ParameterType != typeof(InterruptContext))
                continue;
            
            context.RegisterInterrupt(attribute.ID, ctx => function.Invoke(handler, [ctx]));
        }
        
    }
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
public class LibraryInterruptAttribute : Attribute
{
    public readonly string ID;
    public readonly ValueType[] Parameters;
    public readonly ValueType? ReturnValue;
    
    
    public LibraryInterruptAttribute(string id, ValueType returnValue, params ValueType[] parameters)
    {
        ID = id;
        Parameters = parameters;
        ReturnValue = returnValue;
    }
}