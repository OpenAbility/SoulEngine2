using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using SoulEngine.SequenceScript.Machine;
using SoulEngine.Util;
using ExecutionContext = System.Threading.ExecutionContext;
using ValueType = SoulEngine.SequenceScript.Machine.ValueType;

namespace SoulEngine.SequenceScript.Compile;

public static class StandardLibraryGenerator
{
    public static string GenerateStandardLibrary(Type type)
    {
        StringBuilder builder = new StringBuilder();

        builder.AppendLine("// Standard library generated by StandardLibraryGenerator");

        foreach (var function in type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy))
        {

            LibraryInterruptAttribute? attribute = function.GetCustomAttribute<LibraryInterruptAttribute>();
            if(attribute == null)
                continue;

            var matchType = IsValidFunc(attribute, function);
            
            if(matchType == MatchType.None)
                continue;
            
            if(attribute.ID.StartsWith("$"))
                continue;

            builder.Append("proc extern " + ConvertType(attribute.ReturnValue) + " " + attribute.ID + "(");
            
            for (int i = 0; i < attribute.Parameters.Length; i++)
            {
                string name = "attribute" + i;

                if (matchType == MatchType.ParameterInput)
                    name = function.GetParameters()[i].Name!;
                else if (matchType == MatchType.ComplexParameterInput)
                    name = function.GetParameters()[i + 1].Name!;
                
                builder.Append(ConvertType(attribute.Parameters[i]) + " " + name);
                if (i < attribute.Parameters.Length - 1)
                    builder.Append(", ");
            }

            builder.AppendLine("); // Generated from " + function.Name);
        }

        return builder.ToString();
    }

    private static MatchType IsValidFunc(LibraryInterruptAttribute attribute, MethodInfo function)
    {
        ParameterInfo[] parameters = function.GetParameters();

        if (attribute.Parameters.Length == parameters.Length)
        {
            var mismatch = !function.ReturnType.IsAssignableTo(ConvertTypeToNative(attribute.ReturnValue ?? ValueType.Void));
            
            for (var i = 0; i < parameters.Length; i++)
            {
                if(mismatch)
                    break;

                if (attribute.Parameters[i] == ValueType.Floating)
                    mismatch = parameters[i].ParameterType != typeof(float);
                if (attribute.Parameters[i] == ValueType.String)
                    mismatch = parameters[i].ParameterType != typeof(string);
                if (attribute.Parameters[i] == ValueType.Integer)
                    mismatch = parameters[i].ParameterType != typeof(int);
                if (attribute.Parameters[i] == ValueType.Boolean)
                    mismatch = parameters[i].ParameterType != typeof(bool);
                if (attribute.Parameters[i] == ValueType.Void)
                    mismatch = true;
                if (attribute.Parameters[i] == ValueType.Bogus)
                    mismatch = true;
            }

            if (!mismatch)
                return MatchType.ParameterInput;
        }
        
        if (attribute.Parameters.Length + 1 == parameters.Length)
        {
            bool mismatch = parameters[0].ParameterType != typeof(InterruptContext) || !function.ReturnType.IsAssignableTo(ConvertTypeToNative(attribute.ReturnValue ?? ValueType.Void));
            
            for (var i = 0; i < parameters.Length - 1; i++)
            {
                if(mismatch)
                    break;
                
                if (!parameters[i + 1].ParameterType.IsAssignableFrom(ConvertTypeToNative(attribute.Parameters[i])))
                    mismatch = true;
            }

            if (!mismatch)
                return MatchType.ComplexParameterInput;
        }
        
        
        if (parameters.Length == 1 &&
            parameters[0].ParameterType == typeof(InterruptContext))
            return MatchType.SingleParameter;
        

        return MatchType.None;
    }

    private static string ConvertType(ValueType? valueType)
    {
        return valueType switch
        {
            ValueType.Integer => "int",
            ValueType.Floating => "float",
            ValueType.Boolean => "bool",
            ValueType.String => "string",
            ValueType.Handle => "handle",
            ValueType.Void => "void",
            null => "void",
            _ => throw new ArgumentOutOfRangeException(nameof(valueType), valueType, null)
        };
    }
    
    private static Type ConvertTypeToNative(ValueType? valueType)
    {
        return valueType switch
        {
            ValueType.Integer => typeof(int),
            ValueType.Floating => typeof(float),
            ValueType.Boolean => typeof(bool),
            ValueType.String => typeof(string),
            ValueType.Handle => typeof(object),
            _ => typeof(void)
        };
    }
    

    public static void RegisterInterrupts(object handler, SoulEngine.SequenceScript.Machine.ExecutionContext context)
    {
        
        foreach (var function in handler.GetType().GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy))
        {

            LibraryInterruptAttribute? attribute = function.GetCustomAttribute<LibraryInterruptAttribute>();
            if(attribute == null)
                continue;

            MatchType match = IsValidFunc(attribute, function);
            
            if(match == MatchType.None)
                continue;
            
            if(match == MatchType.SingleParameter)
                context.RegisterInterrupt(attribute.ID, ctx => function.Invoke(handler, [ctx]));
            else if (match == MatchType.ParameterInput)
            {
                context.RegisterInterrupt(attribute.ID, ctx =>
                {
                    object[] parameters = new object[attribute.Parameters.Length];

                    for (int i = parameters.Length - 1; i >= 0; i--)
                    {
                        parameters[i] = ctx.PopStack().Raw;
                    }

                    object? ret = function.Invoke(handler, parameters);
                    
                    if(attribute.ReturnValue != ValueType.Void && attribute.ReturnValue != null)
                        ctx.PushStack(new DynValue(attribute.ReturnValue.Value, ret!));
                });
            } else if (match == MatchType.ComplexParameterInput)
            {
                context.RegisterInterrupt(attribute.ID, ctx =>
                {
                    object[] parameters = new object[attribute.Parameters.Length + 1];

                    parameters[0] = ctx;
                    for (int i = attribute.Parameters.Length - 1; i >= 0; i--)
                    {
                        parameters[i + 1] = ctx.PopStack().Raw;
                    }

                    object? ret = function.Invoke(handler, parameters);
                    if(attribute.ReturnValue != ValueType.Void && attribute.ReturnValue != null)
                        ctx.PushStack(new DynValue(attribute.ReturnValue.Value, ret!));
                });
            }
        }
        
    }
    
    private enum MatchType
    {
        None,
        SingleParameter,
        ParameterInput,
        ComplexParameterInput
    }
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
public class LibraryInterruptAttribute : Attribute
{
    public readonly string ID;
    public readonly ValueType[] Parameters;
    public readonly ValueType? ReturnValue;
    
    
    public LibraryInterruptAttribute(string id, ValueType returnValue, params ValueType[] parameters)
    {
        ID = id;
        Parameters = parameters;
        ReturnValue = returnValue;
    }
}